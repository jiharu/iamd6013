<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<title>IAMD6013</title>
    
<link href="css/site.css" media="all" rel="stylesheet" type="text/css" />
<link href="css/highlight.default.css" media="all" rel="stylesheet" type="text/css" />
  
<script src="js/jquery.js"></script>
<script src="js/showdown.js" type="text/javascript"></script>

<link rel="icon" type="image/x-icon" href="favicon.ico" />
</head>
<body>
<!--
Write the markdown code below.
A guide to markdown syntax is at http://daringfireball.net/projects/markdown/
-->

<div style="display: none" id="sourcetext">

# Endless Forms Most Beautiful II
*Note: This class shares material with another of Ji's classes, Digital Atelier I: Discovery.*  

- Theory: Endless Forms Most Beautiful 2: William Latham & Cellular Automata

	***“How can non-organic materials show life-like behaviors?”***  
	***“How can machines be creative?”***

- Reading:

	- Deussen, Oliver, and Lintermann, Bernd. Digital Design of Nature. 12. 1. William Latham. Springer, 2002. p.228-231.[OCAD U library link](https://books-scholarsportal-info.ocadu.idm.oclc.org/en/read?id=/ebooks/ebooks2/springer/2011-04-28/2/354027104X#page=215)    
	- (Related chapters) Todd, S. and W. Latham. Evolutionary Art and Computers. Academic Press, Inc. 1994. Chap 1. Why use computers make art? p.1-14. [PDF link](pdf/LathamEvolutionaryArtAndComputersCh1.pdf) 
	-  Wolfram, Stephen. Chapter 6: Starting from Randomness, Section 2: Four Classes of Behavior, A New Kind of Science, https://www.wolframscience.com/nks/ [Online; accessed Dec 2018]

- Student-led presentations & discussions.
	- Tabitha Fisher
	- Shahrzad Amin

- Practice
	- Drawing a flowchart.  
	- Javascript coding.  

____________________________________
# Krzysztof Wodiczko

Krzysztof Wodiczko was born 1943 in Warsaw, Poland, lives and works in New York City, in Cambridge, Massachusetts, and in Warsaw.  He is renowned for his large-scale projections on architectural facades, and monuments aimed to enforce public voice and expression of the marginalized city residents. Krzysztof Wodiczko is a recipient of 4th Hiroshima Art Prize "for his contribution as an artist to the world peace".  He  is  Professor of Art, Design and the Public Domain at Harvard’s Graduate School of Design. 

- [www.krzysztofwodiczko.com](https://www.krzysztofwodiczko.com/)  
- [Guerrilla Girls and Krzysztof Wodiczko In Conversation- Hirshhorn Museum, Feb 13, 2018](https://www.youtube.com/watch?v=KiQ4rwnWrT0)  


_____________________________________

# Exercise 2: Working with William Latham	
##"Artist as Gardener"

## References
- William Latham webpage: [latham-mutator.com](http://latham-mutator.com/) 
- Latham, William and Todd, Stephen, eds. 1992. Evolutionary Art and Computers. Academic Press Inc.

 
### FormSynth evolutionary drawing system  
An experimental drawing system created by William Latham and used by him to produce many works between 1984-1987. This was a system for drawing on paper and not on the computer. The rules, sphere, cone, bulge, scope, and so on, were typed out, and Latham applied them by hand. Repeated application of the rules created an evolutionary tree of complex forms. 1984.  

![latham](http://latham-mutator.com/blog/wp-content/uploads/1984/01/FormSynthTechnical1984Q1No2.jpg)  

### Hand-drawn Form Synth by William Latham  
Form Synth large-scale drawing showing the evolution of complex forms using a simple set of transformation rules including (beak, bulge, twist). Biro on paper, dimensions 2m x 1.5m. 1984.  

![latham](http://latham-mutator.com/blog/wp-content/uploads/1984/04/FormsynthflowArt1984Q2No1.png)  

### Hand-drawn Form Synth by William Latham  
First attempts by William to formalise the Form Synth process – a rule based drawing process – in the form of a flow diagram. Anticipating a move to software of his ideas. 1985.  

![latham](http://latham-mutator.com/blog/wp-content/uploads/1985/01/FormsynthflowArt1985Q1No11.jpg)  

### FormSynth basic program  
Programmed in BBC Basic the computer gave William randomly selected drawing instructions from the Form Synth rule set. William used his brain as the graphics software to imagine what the forms looked like and then drew them. 1985.  

![latham](http://latham-mutator.com/blog/wp-content/uploads/1985/01/FormSBasicSoftware1985Q2No1.jpg)  

### William Latham sketching a FormSynth drawing  
A portrait of William Latham sketching a FormSynth drawing. Here Latham is drawing according to the FormSynth rule set and using his brain as a graphics device. 
2013.

![latham](http://latham-mutator.com/blog/wp-content/uploads/2013/09/SynthPortraitPortrait1984Q2No1.jpg)  

## Video references
- [Evolutionary Art and Computers | William Latham | TEDxOxford, 2015, 11:51](https://youtu.be/MZGOr94468w)

- [Arts/Sciences#15: William Latham - Evolutionary Art, 2014, 1:31:12](https://www.youtube.com/watch?v=UrLtL3TvBL0)  

- [Secret Passions - William Latham, 2009, 8:08](https://www.youtube.com/watch?v=AN6ngsckRZs) 

- [Mutator VR Exhibition by William Latham, 2017, 2:46](https://youtu.be/5jBi4KHvnXU)  
A computer art exhibition in virtual reality created by artist William Latham with mathematicians and software developers Stephen Todd and Lance Putnam.
East Gallery at Norwich University of the Arts was the first art gallery venue worldwide to exhibit Mutator VR, which used original software modelled on the processes of evolution to blend organic imagery with state-of-the-art, real-time computer animation, creating a highly immersive and original audience experience. A film by Copper Crayon.

## Evolutionary Systems
There have been more than four decades of computational systems inspired by natural evolution. It has become a major field of machine learning and optimization. Beyond AI, it has been used in hardware and circuit design, robotics, and more recently in industrial design and architecture. It has of course also been deeply explored in art and music.

[An introduction of evolutionary systems, from DATT4950 York University.](http://grrrwaaa.github.io/courses/datt4950/evo.html)  

### Heredity and variation: aesthetic selection
- Interactive selection. Pioneered by Dawkins' [Biomorphs program](http://www.bbc.com/news/av/science-environment-36367745/richard-dawkins-discusses-biomorphs-in-1991) and Karl Sims' [Galapagos](http://www.karlsims.com/galapagos/), [Genetic Images](https://vimeo.com/7723361), in which several candidates are presented to human observers, who apply the selection manually. Also known as **aesthetic selection**. A problem here is that the human becomes the bottleneck of evolution, constraining population sizes and rates of evolution to very small scales. It may arguably also tend toward selecting for the aesthetic average rather than the remarkable.

	- An interesting variation is to make the selection continuous and implicit. Jon McCormack's [Eden](https://www.youtube.com/watch?v=Yrww68pnqqM) measured fitness globally according to how long gallery visitors remained in front of a particular evolving sub-population.

- A viability-oriented form of artificial evolution may be used for more theoretical and aesthetic branches of artificial life research. The viability measure arises as an emergent property of underlying laws of the world, such as the requirement to maintain energetic/metabolic balance or to maintain structural integrity, as well as the collective effects of multiple species and non-living dynamics within the environment. For this reason it is sometimes referred to as ecosystemic selection. See discussion here. This may still incorporate indirect interaction from human agents if desired.

### Artificial evolution
- Genetic representation: Genotypes
- Development & population: Phenotypes
- Selection: Fitness function vs. Aesthetic vs Artificial-Natural or Random
- Variation of new generation: Mutation & Crossover (sexual)

![evosystem](https://cdn-images-1.medium.com/max/1600/1*odW0CYMTeS-R5WW1hM0NUw.jpeg)  

#### Related magazine articles
- [Introduction to Evolutionary Algorithms by Devin Soni](https://towardsdatascience.com/introduction-to-evolutionary-algorithms-a8594b484ac)  
- [Understanding Genetic Algorithms. A use case in organizational field by Alfonso Fernández](https://becominghuman.ai/understanding-genetic-algorithms-a-use-case-in-organizational-field-2087c30fb61e)  

#### Case study
- [Cryptokitties](https://www.cryptokitties.co/catalogue/exclusive-cats)  
- [Meet CryptoKitties, the $100,000 digital beanie babies epitomizing the cryptocurrency mania, CNBC](https://www.cnbc.com/2017/12/06/meet-cryptokitties-the-new-digital-beanie-babies-selling-for-100k.html)  
- [CRYPTOKITTIES GUIDE HIDDEN GENES | HOW TO CREATE FANCY CRYPTO KITTIES, 8:39](https://www.youtube.com/watch?v=MtTyStoOLqo) 

## Exploration on Form Synth Ideas
### 1. Creating a rule of growth (morphogenesis) for a new species (20 min)
- Define the initial status on paper: form & behaviors
	- Form
		- A small numbers of simple forms.
		<!--- Form/dimension: 2D (e.g., triangle, circle, square..) or 3D (e.g., box, cone, sphere..)-->
	- Development	
		- Behaviors/transformations || deformations || mathematical functions; e.g. bulge, beak, slice, scoop, rotate, bend, twist, add, subtract, multiply, etc.  
		- Methods of choosing among elements: e.g. sequence, dice rolls, free choice, etc.	
	- The final rule should be in a written form of instructions or a flow chart.

### 2. Test your rule by creating a population of phenotype expressions (30 min)
- ***Create a population of development drawings*** based on your defined rules.	
	- Each time your rule asks you to make a choice, **note the choice made along with the drawing**. This is the genetic information (**genotype**) corresponding to your drawing (**phenotype**).

- Refining your rule:
	- If you are not satisfied with the results, go back to step 1 and modify your rule.
	- If you are satisfied with your results, post your rule and drawings on the wall. Don't forget to sign it. Then move to step 3.
 

### 3. Breeding the population with an evolutionary approach (30 min)

- Selection: select among your population of drawings which ones will become parents to new offspring. You may use these methods:
	- Random selection	 	
	- Aesthetic selection
		- By artist(s)
		- By participant(s)  
	- Artificial Natural selection	
		- By system to offer environmental conditions   	
	- Fitness/viability selection (function)  

- Heredity: create a new population of offspring drawings using your rule, in which each drawing is a variation of a selected parent. The offspring should mostly follow the same genetic choices within the rule as the parent (asexual reproduction), but with some variations (mutations).

- Continue several generations of selection and heredity to create a family tree. If you are happy, post at least one offspring drawings under your rule on the wall.
	
### 4. Selecting a rule (30 min)
- Go to the wall where defined rules are posted by your fellow artists, and find a rule you like. 
- Take a photo or a copy of the rule, and create more expressions based on it.  
	
### 5. Modifying and creating rule & expression	(30 min)
- If you are satisfied with your drawing from step 4, post your drawing under or near the rule you chose on the wall. Don't forget to sign them.
- If you are not satisfied with your drawing from step 4, modify the rule to make it more interesting for you. Then create new expressions based on your modified rule. Continue until you are satisfied with the results, posting both the modified rule and the expressions under or near the rule you chose. Don't forget to sign them.

## Discussion

### Sol LeWitt and William Latham
- Adding growth through an evolutionary approach (time factor) 
- Artist & draftsman vs. artist & computer (computation)

### William Latham and Casey Reas: biological influence 
- Gene (genotype) & structure (phenotype) vs. agents & process
- Aesthetic selection as fitness function

<!--

## Deliverables
- Complete today's exercises and readings.  
- **Documenting:** Make a record (including photos of drawings, processes, comments) of your experiment Exploration on Form Synth Ideas today as a PDF  file. Your documentation must include your name, school ID, and the results & processes of today's experiment. ***Your documentation should include two sets of: 1. your two flow chart rules (one with one parent, and the other with two (or more) parents), 2. your at least two phenotype drawing(s) according to each rule. The first set is with your rule, and the second set is with a rule(s) by your fellow artist.*** You can add ***short descriptions*** to each images. Due date will be Oct 13 11:59 pm.  
- Reading: Please read articles about ideas behind Processing by Casey Reas and Ben Fry from the book Digital Design Theory edited by Helen Armstrong, Princeton Architectural Press, 2016. [PDF link](CaseyReasDigitalDesignTheory.pdf) 
- Feedback: Please leave your comments here in terms of today's class: [feedback link](https://goo.gl/forms/RSMADAc0Hqtjkx392)-->

# Exercise 4: Cellular Automata
## "The self-organizing emergence of life from non-life"

***How life can emerge from non-life?*** It is a question upon which science can only speculate, as we have no readily available examples of the spontaneous emergence of life for empirical study. However the problem can be approached more generally as the modeling of the emergence of complex structures which evoke life-like characteristics, from simpler dynamic substrates.

The CA model was propsed by Stanislaw Ulam and used by [von Neumann](https://en.wikipedia.org/wiki/Von_Neumann_universal_constructor) -- in the 1940's -- to demonstrate machines that can reproduce themselves. A CA is a discrete model in time, space, and cell states, making it immediately suitable for computational simulation.

The world of a Cellular Automata is a grid of cells (in one, two, or more dimensions), each of which can be in one or another state (e.g. white or black), and which follows simple rules to change its state according to the states of its immediate neighbors.

## Conway's Game of Life, 1970

The most famous CA is probably the Game of Life. It is a 2D automata, which uses a neighbourhood of 8 neighbours, and synchronous update. The transition rule can be stated as follows:

- If the current state is 1 ("alive"):
	- If the neighbor total is less than 2: New state is 0 ("death by loneliness")
	- Else if the neighbor total is greater than 3: New state is 0 ("death by overcrowding")
	- Else: State remains the same ("alive")
- If the current state is 0 ("dead"):
	- If the neigbor total is exactly 3: New state is 1 ("reproduction")
	- Else: State remains the same ("dead")
	
The Game of Life produces easily recognizable higher-level formations including stable objects, oscillatory objects, mobile objects and objects that produce or consume others, for example, which have been called 'ponds', 'gliders', 'eaters', 'glider guns' and so on. 	

- [Stephen Hawkings The Meaning of Life (John Conway's Game of Life segment), 3:29](https://www.youtube.com/watch?v=CgOcEZinQ2I&t=2s)  

- [Does John Conway hate his Game of Life?, 6:53](https://www.youtube.com/watch?v=E8kUJL04ELA&feature=youtu.be) 	
	
- [The Game of Life - The Nature of Code by The coding train.](https://www.youtube.com/watch?v=tENSCEO-LEc)  	
	
> The spatial directions of cells do not matter, only the total value of all neighbors is used, along with the current value of the cell itself. Note also that these rules mean that the Game of Life is not reversible: from a given state it is not possible to determine the previous state.

## Langton's Ant, 1986

- [Langton's Ant (and Life)](http://datagenetics.com/blog/september22015/index.html)

- [Langton's Ant](http://en.wikipedia.org/wiki/Langton%27s_ant) is a mobile CA in a 2D, two-state space, with very simple rules:
	- At a white square, turn 90° right, flip the color of the square, move forward one unit
	- At a black square, turn 90° left, flip the color of the square, move forward one unit
		

The [original video by Christopher Langton](http://www.youtube.com/watch?v=w6XQQhCgq5c), including examples of multiple ants (and music by the Vasulkas):

### Termites

Mitchel Resnick's termite model is a random walker in a space that can contain woodchips, in which each termite can carry one woodchip at a time. The program for a termite looks something like this:

- Look at the space just in front of me
- If it is empty, move forward and randomly change direction (random walk)
- Else if it is occupied by a woodchip:
	- If I am carrying a wood chip, drop mine where I am and turn around
	- Else move forward and pick up the woodchip
	
Over time, the termites begin to collect the woodchips into small piles, which gradually coalesce into a single large pile of chips.

> Note that Termites and Langton's Ant CAs are closely related to the turtle graphics often used for L-systems,

- [L-Systems - The Nature of Code by the codding train](https://www.youtube.com/watch?v=f6ra024-ASY)  

##￼Essential components
The essential components that define a cellular system are:

- **Cellular space:** A collection of cells arranged into a discrete lattice, such as a 2D grid. The space is usually 1D, 2D or 3D, but rarely greater. 

- **Cell states:** The information representing the current condition of a cell. In binary CAs this is simply either 0 or 1.

- **Initial conditions:** What state the cells are in at the start of the simulation.

- **Neighborhood:** The set of adjacent/nearby cells that can directly influence the next state of a cell. The most common 2D neighborhoods are: 

	![neighborhoods](http://www.economicsnetwork.ac.uk/cheer/ch17/hand1.gif)

- **State transition function:** The rule that a cell follows to update its state, which depends on the current state and the state of the neighborhood. It gives the cell state[t+1] as a function of the states[t] of itself and neighbours. 

	The transition rule always reads from the 'past' lattice, and always writes to the 'future' lattice. After all cells are updated, either the 'future' is copied to the 'past', or the 'future' and 'past' lattices are swapped, since the future of yesterday is the past of tomorrow. 

- **Time axis:** The cells are generally updated in a discrete fashion, which may be synchronous (all cells update simultaneously) or asynchronous (cells update sequentially).

- **Boundary conditions:** What happens to cells at the edges of the space. A periodic boundary 'wraps around' to the opposite edge; a static boundary always has the same state, a reflective boundary mirrors the neighbor state.


## Explorations of Cellular Automata using P5.js

### Conway's Game of Life

>- If the current state is 1 ("alive"):
	- If the neighbor total is less than 2: New state is 0 ("death by loneliness")
	- Else if the neighbor total is greater than 3: New state is 0 ("death by overcrowding")
	- Else: State remains the same ("alive")
- If the current state is 0 ("dead"):
	- If the neigbor total is exactly 3: New state is 1 ("reproduction")
	- Else: State remains the same ("dead")
	


```javascript

// declare global variables,
// that can be used in any function
// and persist through the program's lifetime:

// cell size in pixels:
let cell_size = 8;
// number of cells in each dimension
// (depends on cell_size and canvas size):
let columns, rows;

// cells is defined as an empty array
// (this will become a "2D" array -- an array of arrays):
let cells = [];
// we also need a second 2D array for the next generation
// (at each frame we calculate new cell values and store them in newcells
// and then swap cells and newcells for the next frame)
let newcells = [];

// setup() runs once when the program starts
// use it to define the canvas
// and initialize the global state
function setup() {
  // create a p5.js canvas that fills the available area:
  canvas = createCanvas(windowWidth, windowHeight);
  // initialize graphics: black background, no borders:
  background(0);
  noStroke();
  
  // number of cells in each dimension
  // (depends on cell_size and canvas size):
  columns = width/cell_size;
  rows = height/cell_size;
  
  // initialize the 2D arrays of cells and newcells:
  // first create a list of rows:
  
  for (let r = 0; r < rows; r++) {
    // create a new row (array of arrays):
    cells[r] = [];
    newcells[r] = [];
    // for each column in this row:
    for (let c=0; c < columns; c++) {
      // create a new cell
      // state is either 0 or 1
      cells[r][c] = floor(random(2));
      // newcells starts off identical to cells:
      newcells[r][c] = cells[r][c];
    }
  }
}

// the draw() function is called repeatedly
// about 60 times a second (if the computer is fast enough)
function draw() {
  
  // compute the new generation as 'newcells'
  // by reading from the states in 'cells':
  // row by row, column by column:
  for (let r = 0; r < rows; r++) {
    // for each column in this row:
    for (let c=0; c < columns; c++) {
      // get this cell's current state:
      let cell = cells[r][c];
      
      // special case for border cells:
      // i.e. where the cell's row is 0 or (rows-1)
      // or the cell's column is 0 or (columns-1)
      // these cells do not have a full neighbourhood
      if (c <= 0 || c >= columns-1 || r <= 0 || r >= rows-1) {
        // some options:
        // let border cells be always dead
        newcells[r][c] = 0;
        // or, let border cells stay the same
        //newcells[r][c] = cell;
        // or, let border cells be always randomized:
        //newcells[r][c] = floor(random(2));
      } else {
        // not a border cell
        
        // get each of the neighbouring cells (from the previous generation):
        let N  = cells[r-1][c  ];
        let S  = cells[r+1][c  ];
        let W  = cells[r  ][c-1];
        let E  = cells[r  ][c+1];
        let NE = cells[r-1][c+1];
        let SE = cells[r+1][c+1];
        let NW = cells[r-1][c-1];
        let SW = cells[r+1][c-1];
        // add them up:
        let sum = N + S + E + W + NE + SE + NW + SW;
        
        // Game of life rules:
        if (cell) {
          // cell is 'alive'
          if (sum < 2 || sum > 3) {
            // death by loneliness or overcrowding
            newcells[r][c] = 0;
          } else {
            // staying alive
            newcells[r][c] = 1;
          }
        } else {
          // cell is 'dead'
          if (sum == 3) {
            // three neighbors, trisexual reproduction:
            newcells[r][c] = 1;
          } else {
            // stay 'dead'
            newcells[r][c] = 0;
          }
        }
      }
    }
  }
  
  // now do another loop to draw it, updating cells as we go:
  for (let r = 0; r < rows; r++) {
    for (let c=0; c < columns; c++) {
      // get the state of this location in the newcells array:
      let cell = newcells[r][c];
      // scale state (0,1) up to greyscale range (0,255):
      fill(cell * 255);   
      // draw a box at this cell's location and size:
      rect(c*cell_size, r*cell_size, cell_size, cell_size);
      // update the old cells array with the new cell value:
      // (if we didn't do this, the CA would not continuously update)
      cells[r][c] = cell;
    }
  }
}

```

### Langton's Ant

>A cellurar space (a 2D grid) of black or white cells is inhabited by one or more ants
these ants face one of four possible directions (north, east, south, or west)
and move one cell at a time, following a very simple rule:
- at a white square, turn 90° right, flip the color of the square, move forward one unit
- at a black square, turn 90° left, flip the color of the square, move forward one unit

```javascript

// declare global variables,
// that can be used in any function
// and persist through the program's lifetime:

// cells is defined as an empty array
// (this will become a "2D" array -- an array of arrays):
let cells = [];
// cell size in pixels:
let cell_size = 8;
// number of cells in each dimension
// (depends on cell_size and canvas size):
let columns, rows;

// this is the ant that will wander around the cellular space:
let ant;

// setup() runs once when the program starts
// use it to define the canvas
// and initialize the global state
function setup() {
  // create a p5.js canvas that fills the available area:
  canvas = createCanvas(windowWidth, windowHeight);
  // initialize graphics: black background, no borders:
  background(0);
  noStroke();

  // number of cells in each dimension
  // (depends on cell_size and canvas size):
  columns = floor(width / cell_size);
  rows = floor(height / cell_size);

  // initialize the 2D array of cells
  // first create a list of rows:
  for (let r = 0; r < rows; r++) {
    // create a new row (array of arrays):
    cells[r] = [];
    // for each column in this row:
    for (let c = 0; c < columns; c++) {
      // create a new cell
      // state is either 0 or 1
      // initially we set the state to 1 (white)
      cells[r][c] = 1;
    }
  }

  // initialize the ant
  ant = {
    // start in the middle of the space:
    x: floor(columns / 2),
    y: floor(rows / 2),
    // with a random heading:
    // ants can only face north, east, south, or west
    // we can encode these directions as 0, 1, 2, 3:
    direction: floor(random(4))
  };
}

// the draw() function is called repeatedly
// about 60 times a second (if the computer is fast enough)
function draw() {
  // update the ant:
  // the ant's rules depend on the state of the cell it stands on:
  let cell = cells[ant.y][ant.x];
  // if the cell is white:
  if (cell) {
    // turn clockwise:
    ant.direction--;
    // make sure the direction is still in the range 0, 1, 2, 3:
    if (ant.direction == -1) {
      ant.direction = 3;
    }
    // now flip the square color to black:
    cells[ant.y][ant.x] = 0;
  } else {
    // the cell is black
    // turn anti-clockwise:
    ant.direction++;
    // make sure the direction is still in the range 0, 1, 2, 3:
    if (ant.direction == 4) {
      ant.direction = 0;
    }
    // now flip the square color to white:
    cells[ant.y][ant.x] = 1;
  }

  // move forward one unit:
  if (ant.direction == 0) {
    // North:
    ant.y--;
  } else if (ant.direction == 1) {
    // East:
    ant.x++;
  } else if (ant.direction == 2) {
    // South:
    ant.y++;
  } else if (ant.direction == 3) {
    // West:
    ant.x--;
  }

  // if we hit the edge of the canvas, wrap around:
  if (ant.x < 0) {
    ant.x += columns;
  } else if (ant.x >= columns) {
    ant.x -= columns;
  }
  if (ant.y < 0) {
    ant.y += rows;
  } else if (ant.y >= rows) {
    ant.y -= rows;
  }

  // draw the space:
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < columns; c++) {
      let cell = cells[r][c];
      // scale state (0,1) up to greyscale range (0,255):
      fill(cell * 255);
      // draw a box at this cell's location and size:
      rect(c * cell_size, r * cell_size, cell_size, cell_size);
    }
  }

  // draw the ant:
  fill("red");
  rect(ant.x * cell_size, ant.y * cell_size, cell_size, cell_size);
}
```


Christopher Langton also proposed a more concise self-reproducing CA than von Neumann's, which has since been further improved upon using artificial evolutionary techniques:

- [Langton's Loops, 3:35](https://www.youtube.com/watch?v=2iDc4C6vbcc) 

### Wolfram's Rule 30

Stephen Wolfram, author of Mathematica, performed extensive research on CAs and uncovered general classes of behaviour comparable to dynamical systems. A commonly referenced example is his 'rule 30', which is a 1D CA displayed below as a stacked trace (history goes down) -- whose pattern is reminiscent of some naturally occurring shell patterns:

![Evolution of a 1D CA: rule 30](image/ca_shells.jpg)  

![Rule 30](image/rule30.png)

[Here it is in p5.js](https://codepen.io/Hrrr/pen/MOJmwL?editors=0010)

```javascript
// declare global variables,
// that can be used in any function
// and persist through the program's lifetime:
let columns, rows, generation;
// cells is defined as an empty array:
let cells = [];

// setup() runs once when the program starts
// use it to define the canvas
// and initialize the global state
function setup() {
  // create a p5.js canvas that fills the available area:
  canvas = createCanvas(windowWidth, windowHeight);
  // initialize graphics: black background, no borders:
  background(0);
  noStroke();

  // define number of rows & columns by pixel dimensions:
  columns = floor(windowWidth);
  rows = floor(windowHeight);
  // initialize the simulation data:
  reset();
}

function reset() {
  // set each cell to a random initial value:
  for (let i = 0; i < columns; i++) {
    // random(2) picks a decimal number greater than or equal to zero, and less than 2.
    // floor() rounds this down to the nearest whole number
    // so the result is either exactly 0 or 1:
    cells[i] = floor(random(2));
  }
  // start at the zeroth generation:
  generation = 0;
}

// the draw() function is called repeatedly
// about 60 times a second (if the computer is fast enough)
function draw() {
  // draw each cell:
  for (let i = 0; i < columns; i++) {
    // get the current cell
    let cell = cells[i];
    // draw it
    // set the paint color to black (0) or white (255)
    // according to the cell value
    fill(cell * 255);
    // draw a box, at the cells's column,
    // at the current generation's row,
    // of size 1 pixel by 1 pixel
    rect(i, generation, 1, 1);
  }

  // increment the current generation count:
  generation++;
  // if we haven't yet filled the screen:
  if (generation < rows) {
    // compute a new generation:
    // create a new array to hold the next generation of cells
    // (need to make a new array, rather than modifying in place,
    // so that cells and neighbours properly update in parallel)
    let newcells = [];
    // compute each new cell value:
    for (let i = 0; i < columns; i++) {
      // get the current cell, and its left and right neighbours:
      let left = cells[i - 1];
      let center = cells[i];
      let right = cells[i + 1];
      // call the rule() function to determine the new cell value:
      newcells[i] = rule(left, center, right);
    }
    // replace the "cells" variable with the new generation
    // to be used on the next frame:
    cells = newcells;
  } else {
    // else if we *have* filled the screen,
    // reset the simulation:
    reset();
  }
}

// returns a new cell state according to a neighborhood
// of three input cells
function rule(left, center, right) {
  // it is possible that the left or right neighbour are undefined
  // (this happens at the left-most and right-most boundaries of the array
  if (left == undefined) {
    // the left-most cell has no left neihbour,
    // so return the state unchanged:
    return center;
  } else if (right == undefined) {
    // the right-most cell has no right neihbour,
    // so return the state unchanged:
    return center;
  } else if (left == 1 && center == 1 && right == 1) {
    return 0;
  } else if (left == 1 && center == 1 && right == 0) {
    return 1;
  } else if (left == 1 && center == 0 && right == 1) {
    return 0;
  } else if (left == 1 && center == 0 && right == 0) {
    return 1;
  } else if (left == 0 && center == 1 && right == 1) {
    return 1;
  } else if (left == 0 && center == 1 && right == 0) {
    return 0;
  } else if (left == 0 && center == 0 && right == 1) {
    return 1;
  } else if (left == 0 && center == 0 && right == 0) {
    return 0;
  }
}
```

- [Elementary CA - mathworld.wolfram.com](http://mathworld.wolfram.com/ElementaryCellularAutomaton.html)  

- [Computing a theory of everything | Stephen Wolfram, TED](https://www.youtube.com/watch?v=60P7717-XOQ)  

Wolfram divided CA into four classes, according to their long-term behavior:

- **Class 1:** Evolve to a fixed and homogeneous state.
- **Class 2:** Evolve to simple periodic configurations (limit cycles).
- **Class 3:** Evolve to chaotic patterns 
- **Class 4:** Evolve to complex patterns of localized structures with long transients.  
 
Conway’s Game of Life is a class 4 CA. 

###￼Bottom-up approach
The strategy of making possible complex phenomena by the simulation of simple components.

>In a bottom-up approach the individual base elements of the system are first specified in great detail. These elements are then linked together to form larger subsystems, which then in turn are linked, sometimes in many levels, until a complete top-level system is formed. - wikipedia


---

## Continuous automata

The CAs are mostly discrete, and this is often evident in the results. But there are several ways to approximate fully continuous automata -- and investigate to what extent similar properties or behaviours arise, and whether new properties can arise unique to continuous spaces. At the least, continuous automata are more able to show liquid and diffusive effects:

### Smoothlife

- [Generalized Conway Game of Life - SmoothLife1](https://www.youtube.com/embed/ISQChKRH4NI?list=PL69EDA11384365494)

### Reaction Diffusion

The reaction-diffusion model was proposed by Alan Turing to describe embryo development and pattern-generation ([Turing, A. The Chemical Basic for Morphogenesis.](http://www.dna.caltech.edu/courses/cs191/paperscs191/turing.pdf)); it is still used today in computer graphics ([Greg Turk's famous paper](http://www.cc.gatech.edu/~turk/my_papers/reaction_diffusion.pdf)). RD systems and other differential equation systems can be approximated using continuous automata.

- [Reaction-Diffusion "Coral Growth" Example](https://www.youtube.com/embed/8dTmUr5qKvI?rel=0)  
One approach to simulating RD using CA is the *Gray-Scott* model, as described in [Pearson, J. E. Complex Patterns in a Simple System](http://arxiv.org/pdf/patt-sol/9304003.pdf). A browser-based example is [here](https://pmneila.github.io/jsexp/grayscott/).

## Deliverables
- Documenting (ongoing) in your journal.
	- Please add links to your work in the p5 or Codepen editors. 
	- The links could be: 
		- Your alternation/modification based on Sol Lewitt's rule and expression
		- Your alternation/modification based on Casey Reas' rule and expression. This can be mixed with some of Sol Lewitt's rules.
		- Cellular Automata.
		- Your own alternation.
	  
</div>
	<div class="header">
		
		<h1>IAMD6013</h1>
		<h3>Special Focus <br/>Research and Innovation: <br/>
		<i>Artificial Nature </i></h3>	
		<h4>Winter 2019 </h4>	
		<a href="https://canvas.ocadu.ca/courses/27368">Canvas</a><br/>
		<a href="https://docs.google.com/spreadsheets/d/1UJS1sles269MEr1BGnkPuw7oxuuLUQ75ZF2_cj_XQq8/edit?usp=sharing">Studio visit (make-up)</a><br/><br/>
<!--		<a href="https://docs.google.com/spreadsheets/d/1A7ivclq2jE48kRN1r7zSLgFd93-netnYie5ZIylIdYY/edit#gid=1347846505">Attendance</a><br/><br/>-->
	
		<h3>Schedule</h3>	
				<a href="index.html">Outline</a><br/>
				<a href="week01.html">1. Computational Generative Art</a><br/>
				<a href="week02.html">2-3. Endless Forms Most Beautiful I</a><br/>
				<a href="week04.html">4-5: Endless Forms Most Beautiful II</a><br/>
				<a href="week05.html">4.1: Supplement</a><br/>
				<a href="week06.html">6: A-Life Art</a><br/>
				<a href="week07.html">7: CAS & Art</a><br/>
				<a href="week08.html">8: Artificial Nature & Case Studies</a><br/>
				<!--	<a href="05_refinement.html"></a>5: Refinement (Oct 23) </a><br/>								
				<a href="06_critique.html"></a>6: Presentation / Critique (Oct 25)</a><br/> -->
				
	</div>
	<div class="section">
		<script type="text/javascript">
		//var converter = new Markdown.Converter();
		var converter = new Showdown.converter();
		document.write(converter.makeHtml($('#sourcetext').text()));
		</script>
	</div>
	
	<div class="footer">Haru (Hyunkyung) Ji, 2019</div>
	
</div>
</body>
</html>