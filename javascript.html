<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<title>IAMD6013</title>
    
<link href="css/site.css" media="all" rel="stylesheet" type="text/css" />
<link href="css/highlight.default.css" media="all" rel="stylesheet" type="text/css" />
  
<script src="js/jquery.js"></script>
<script src="js/showdown.js" type="text/javascript"></script>
<script src="js/highlight.pack.js"></script>

<link rel="icon" type="image/x-icon" href="favicon.ico" />
</head>
<body>
<!--
Write the markdown code below.
A guide to markdown syntax is at http://daringfireball.net/projects/markdown/
-->

<div style="display: none" id="sourcetext">

# P5.js example solutions
## Sol LeWitt's wall drawing #118 solution 1

```javascript
// declare global variables,
// that can be used in any function
// and persist through the program's lifetime:
let points = [];

// setup() runs once when the program starts
// use it to define the canvas
// and initialize the global state
function setup() {
  // create a p5.js canvas that fills the available area:
  canvas = createCanvas(windowWidth, windowHeight);
  // initialize graphics state
  background(0);
  stroke(255, 2);
  strokeWeight(0.4);
  
  // place fifty points at random
  // the points should be evenly distributed over the canvas
  for (let i=0; i<50; i++) {
    let p = {
      x: random(width),
      y: random(height)
    };
    //points.push(p);
    points[i] = p;
  }
}

// the draw() function is called repeatedly
// about 60 times a second (if the computer is fast enough)
function draw() {
  for (let p of points) {
    // draw points in a hard pencil
    ellipse(p.x, p.y, 3); 
    
    // all of the points should be connected by straight lines
    for (let q of points) {
      line(p.x, p.y, q.x, q.y);
    }
  }
}
```
## Sol LeWitt's wall drawing #118 solution 2
```javascript
// declare variables visible everywhere
// how many points to draw:
let num_pts = 100;
// control margins around drawing
let margin = 20;

// setup() runs when p5.js is loaded
function setup() {
  // initialize the canvas & graphics state:
  canvas = createCanvas(windowWidth, windowHeight);
  background(0);

  // define an initial point:
  let x1;
  let y1;
  // declare a list of points
  // initially it is empty:
  let points = [];

  // add num new points:
  for (let i = 0; i < num_pts; i++) {
    // pick a new point:
    let x = random(0 + margin, windowWidth - margin);
    let y = random(0 + margin, windowHeight - margin);

    // save this for the next iteration:
    x1 = x;
    y1 = y;

    // define a new object with two properties
    // called "x" and "y":
    let p = {
      x: x1,
      y: y1
    };
    // store this in the array of points:
    points[i] = p;
    // another way:  points.push(p);

    // connect this to all previous points:
    // from 0..i
    for (let j = 0; j < i; j++) {
      // draw line to point j:
      stroke(250, 125, 125, 50);
      strokeWeight(0.7);
      line(x, y, points[j].x, points[j].y);

      // connect it to the previous point:
      stroke(25, 200, 225, 5);
      strokeWeight(0.8);
      if (i != 0) {
        line(x, y, points[i - 1].x, points[i - 1].y);
      }
      // draw a dot at this point:
      stroke(255, 150);
      strokeWeight(3.1);
      point(x, y);
    }
  }

  // see all the points in the developer console:
  //console.log(points);
}
```
## Sol LeWitt's wall drawing #273 solution 1
```javascript
// Wall Drawing #273: Lines to points on a grid. A six-inch (15 cm) grid covering the wall. Lines from the corners, sides, and center of the walls to random points on the grid. Composite (seventh wall): red lines from the midpoints of four sides, blue lines from four corners, yellow lines from the center., 1975

// declare variables visible everywhere
let gridSize = 50; // in pixels
let lineNum = 750; // number of lines to draw
// define colors to use
let red = [255, 50, 50];
let blue = [75, 100, 255];
let yellow = [200, 200, 30];

// setup() runs when p5.js is loaded
function setup() {
  // initialize canvas & graphics state
  canvas = createCanvas(windowWidth, windowHeight);
  strokeWeight(0.8);
  background(0);

  // define the line start points:
  let startPoints = [
    { x: 0, y: 0 }, //cornderRU
    { x: 0, y: height }, //cornderRB
    { x: width, y: 0 }, //cornderLU
    { x: width, y: height }, //cornderLB
    { x: 0, y: height / 2 }, //sideR
    { x: width, y: height / 2 }, //sideL
    { x: width / 2, y: height }, //sideB
    { x: width / 2, y: 0 }, //sideU
    { x: width / 2, y: height / 2 } //center
  ];

  // how many grid locations are there:
  let gridNumW = width / gridSize;
  let gridNumH = height / gridSize;

  // for each line:
  for (let i = 0; i < lineNum; i++) {
    // pick a random point
    // aligned to the grid
    let x = floor(random(0, gridNumW)) * gridSize;
    let y = floor(random(0, gridNumH)) * gridSize;
    
    let l = startPoints.length;
    // alternate start points in turn
    // by modulo with no. of start points:
    let j = i % l;
    // get the properties of this start point:
    let x1 = startPoints[j].x;
    let y1 = startPoints[j].y;
    
    // set the color according to 
    // which start point it is:
    if (0 <= j && j < 4) {
      stroke(blue);    
    } else if (4 <= j && j < 8) {
      stroke(red);              
    } else {
      stroke(yellow);    
    }
    // draw the line:
    line(x, y, x1, y1);
    
    //console.log(j, x1, y1);
  }
}
```
## Sol LeWitt's wall drawing #273 solution 2
```javascript
// setup() runs once when the program starts
// use it to define the canvas
// and initialize the global state
function setup() {
  // create a p5.js canvas that fills the available area:
  canvas = createCanvas(windowWidth, windowHeight);
  // initialize graphics state
  background(0);

  // Wall Drawing #273: Lines to points on a grid. A six-inch (15 cm) grid covering the wall. Lines from the corners, sides, and center of the walls to random points on the grid. Composite (seventh wall): red lines from the midpoints of four sides, blue lines from four corners, yellow lines from the center., 1975

  let grid_size = 40; // pixels in lieu of cm
  let grid_width = width / grid_size;
  let grid_height = height / grid_size;
  // pre-defined start points for lines:
  let origins = [
    { x: 0, y: 0, colour: "blue" },
    { x: width / 2, y: 0, colour: "red" },
    { x: width, y: 0, colour: "blue" },
    { x: 0, y: height / 2, colour: "red" },
    { x: width / 2, y: height / 2, colour: "yellow" },
    { x: width, y: height / 2, colour: "red" },
    { x: 0, y: height, colour: "blue" },
    { x: width / 2, y: height, colour: "red" },
    { x: width, y: height, colour: "blue" }
  ];
  // lines per start point:
  let num_branches = 10;

  // for each start point:
  for (let o of origins) {
    // for each branch:
    for (let i = 0; i < num_branches; i++) {
      // pick a random point on the grid:
      let x = floor(random(grid_width)) * grid_size;
      let y = floor(random(grid_height)) * grid_size;
      // set color & draw line:
      stroke(o.colour);
      line(o.x, o.y, x, y);
    }
  }
}
```
## Sol LeWitt's wall drawing #95 modified solution 1
```javascript
// On a window screen divided vertically into fifteen equal parts, vertical lines, straight, using four colors in all one-, two-, three-, and four-part combinations.

// how many columns (fixed)
let columns = 15;
// pre-define colors to use:
let red = [255, 0, 0];
let black = [100, 100, 100];
let yellow = [255, 255, 0];
let blue = [0, 200, 200];

// 15 palettes, one for each column:
let palette = [
  [red],
  [black],
  [yellow],
  [blue],

  [red, black],
  [red, yellow],
  [red, blue],
  [black, yellow],
  [black, blue],
  [yellow, blue],

  [red, black, yellow],
  [red, black, blue],
  [red, yellow, blue],
  [black, yellow, blue],

  [red, black, yellow, blue]
];

// setup() runs once after p5.js loads:
function setup() {
  // initialize canvas and graphics state:
  createCanvas(windowWidth, windowHeight);
  //background(128);
  strokeWeight(0.5);

  // width of each column (in pixels)
  let column_width = width / columns;
  // how many lines to draw per column?
  let num_lines = Math.floor(column_width / 3);    
  let line_spacing = column_width/num_lines;

  // for each column:
  for (let i = 0; i < columns; i++) {
    // position of left-hand side of column:  
    let x = column_width * i;
    // get color palette for this column:
    let colors = palette[i];
    // now draw each line of the column:
    for (let j = 0; j < num_lines; j++) {
      // get the line color from the palette:
      stroke(colors[j % colors.length]);
      // get the x position of this line:
      // left-hand side of column, plus
      // j times the step size per line
      let xp = x + (j * line_spacing);
      // draw the line from top to bottom
      line(xp, 0, xp, height);
    }
  }
}
```
## Sol LeWitt's wall drawing #95 modified solution 2
```javascript
// setup() runs once when p5.js starts
function setup() {
  // create a p5.js canvas that fills the available area:
  canvas = createCanvas(windowWidth, windowHeight);
  // initialize graphics state
  background(255); // background is white
  strokeWeight(0.5); // lines have half-pixel width
  
  // On a wall (paper) divided vertically into fifteen equal parts, vertical lines, not straight, using four colors in all one-, two-, three-, and four-part combinations.
  let columns = 15;
  let column_width = width / columns; // in pixels
  
  // pre-define all the color combinations 
  // as a list of lists (array of arrays):
  let palettes = [
    // one-part:
    ["red"],
    ["black"],
    ["yellow"],
    ["blue"],
    // two-part:
    ["red", "black"],
    ["black", "yellow"],
    ["yellow", "blue"],
    ["blue", "red"],
    ["red", "yellow"],
    ["black", "blue"],
    // three-part:
    ["red", "black", "yellow"],
    ["black", "yellow", "blue"],
    ["yellow", "blue", "red"],
    ["blue", "red", "black"],
    // four-part:
    ["red", "black", "yellow", "blue"]
  ];
  
  // draw each column in turn:
  for (let i = 0; i < columns; i++) {
    // get the palette for this column:
    let palette = palettes[i];
    
    // for each line in this column:
    let num_lines = column_width / 4;
    for (let j = 0; j < num_lines; j++) {
      // pick a color from the palette:
      // (alternating each line by j modulo palette size)
      stroke(palette[j % palette.length]);
      // get the horizontal location within the column:
    //  let x = column_width * (i + j/num_lines);      
      let x = column_width/num_lines * j + (i * column_width) ;
      // straight lines:
      // draw a line from x at the top to x at the bottom
      // line(x, 0, x, height);
      
      // non-straight lines:
      // pick a random point deviated from the line 
      // as a 'control point' to create a bezier curve:
      let deviation = 10;
      let x_deviated = x + (deviation*random(-1, 1));
      let y_deviated = height * random();
      // draw a line from x at the top to x at the bottom
      // deviating toward x1,y1 along the way:
      bezier(x,           0, 
             x_deviated,  y_deviated, 
             x_deviated,  y_deviated, 
             x,           height);
    }
  }
}
```
## Animating elements solution 01
```javascript
let num = 30;
let elements = [];

function setup() {
  canvas = createCanvas(windowWidth, windowHeight);
  stroke("red");

  for (let i = 0; i < num; i++) {
    elements[i] = {
      x: random(0, width),
      y: random(0, height),
      r: random(0.2, 20)
    };
  }
}

function draw() {
  background(0, 3);
  for (let i = 0; i < num; i++) {
    let e = elements[i];
    
    e.x += 5;
    e.y += random(-2, 2);

    if (e.x < 0) {
      //x = x + width;
      e.x += width;
    } else if (e.x > width) {
      //x = x - width;
      e.x -= width;
    }

    if (e.y < 0) {
      //y = y + height;
      e.y += height;
    } else if (e.y > height) {
      //y = y - height;
      e.y -= height;
    }
    fill(255, 30);
    ellipse(e.x, e.y, e.r);
  }
}
```
## Animating elements solution 02
```javascript
// form: circle
// behaviour 1: wander by a random walk
// behaviour 2: if leaving one edge of the canvas, appear at the other edge of the canvas
// process: a canvas of several elements of varying size, initially placed at random. each element has a different speed. draw each element filled in white. also draw a faint line between each possible pair of elements. 

// global variables (visible by all functions):
// a list of elements
let elements = [];

// setup() is called once when p5.js is loaded
function setup() {
  // initialize the canvas
  createCanvas(windowWidth, windowHeight);
  background(100);

  // how many elements to make:
  let num_elements = 25;
  // a canvas of several elements
  for (let i = 0; i < num_elements; i++) {
    // create one more element for the list:
    elements[i] = {
      // initially placed at random:
      x: random(width),
      y: random(height),
      // of random size
      radius: random(3, 10),
      // each element has a different speed. 
      speed: random(3, 10)
    };
  }
}

// the animation
// draw() is called 60 times per second:
function draw() {
  // fade toward black by 2%
  // (it will not quite reach black)
  background(0, 2);

  for (let i = 0; i < elements.length; i++) {
    let e = elements[i];

    // behaviour 1: wander by a random walk
    e.x += random(-e.speed, e.speed);
    e.y += random(-e.speed, e.speed);

    // behaviour 2: if leaving one edge of the canvas, appear at the other edge of the canvas
    if (e.x < 0) {
      e.x += width;
    } else if (e.x > width) {
      e.x -= width;
    }
    if (e.y < 0) {
      e.y += height;
    } else if (e.y > height) {
      e.y -= height;
    }

    // draw each element
    // as a white-filled circle
    fill(255);
    ellipse(e.x, e.y, e.radius);
  }
  
  // draw a faint line between each possible pair of elements.
  // set the stroke color to transparent white:
  stroke(255, 2);
  // for each element
  for (let i = 0; i < elements.length; i++) {
    let e = elements[i];
    // for each other element
    for (let j = 0; j < elements.length; j++) {
      let e1 = elements[j];
      // draw the line between them
      line(e.x, e.y, e1.x, e1.y);
    }
  }
}
```
## Reas' Process 4

```
// Reas' Process series instructions listed at http://reas.com/compendium_text

// Process 4
// A rectangular surface filled with varying sizes of Element 1. Draw a line from the centers of Elements that are touching. Set the value of the shortest possible line to black and the longest to white, with varying grays representing values in between.
// E1: F1 + B1 + B2 + B3 + B4
// F1: Circle
// B1: Move in a straight line
// B2: Constrain to surface
// B3: Change direction while touching another Element
// B4: Move away from an overlapping Element

// declare global variables
// (that can be used in any function
// and persist through the program's lifetime)
// here:

// make this true to see the elements:
// make it false to show the final work:
let show_elements = true;

// a list of the elements in the space:
let elements = [];
// how many elements to make:
let num_elements = 100;
// how fast each element moves per frame:
let speed = 1/4;
// how fast they turn when overlapping:
let turn_rate = 1 / 150;
// how fast they avoid when overlapping:
let avoid_rate = 1 / 150;
// minimum element size (as fraction of canvas width):
let min_size = 0.01;
// maximum element size (as fraction of canvas width):
let max_size = 0.1;

// setup() runs once when the program starts
// use it to define the canvas
// and initialize the global state
function setup() {
  // create a p5.js canvas that fills the available area:
  canvas = createCanvas(windowWidth, windowHeight);
  // initialize graphics:
  background(128);
  noFill();

  // create the elements:
  for (let i = 0; i < num_elements; i++) {
    // define a new element:
    let e = {
      // random position within canvas:
      x: random(width),
      y: random(height),
      // of varying size:
      radius: width * random(min_size, max_size),
      // and varying direction:
      angle: random(-Math.PI, Math.PI)
    };
    // add to the list:
    elements[i] = e;
    // or: elements.push(e);
  }
}

// the draw() function is called repeatedly
// about 60 times a second (if the computer is fast enough)
function draw() {
  if (show_elements) {
    // clear the canvas to black
    background(0);
  } else {
    // clear the canvas to black (color 1% per frame)
    background(0, 2);
  }

  // update all the elements and draw the result:
  for (let i = 0; i < elements.length; i++) {
    let e = elements[i];

    // B1: Move in a straight line
    // get the change in x (delta x)
    // and the change in y (delta y)
    // according to the element direction (angle)
    let dx = Math.cos(e.angle);
    let dy = Math.sin(e.angle);
    // add this velocity to the element position:
    e.x += dx * speed;
    e.y += dy * speed;

    // check every other element to see if touching:
    for (let j = 0; j < elements.length; j++) {
      // don't check agsinst self:
      if (i == j) { continue; } // jumps to the next j

      // get the other element:
      let e1 = elements[j];
      // to get the distance
      // we need the relative vector rx,ry
      // from e1 to e:
      let rx = e.x - e1.x;
      let ry = e.y - e1.y;
      // by Pythagoras' theorem:
      let distance = Math.sqrt(rx * rx + ry * ry);
      // this is distance between the centers
      // if the elements are overlapping,
      // the distance is less than their radius total
      if (distance < (e.radius + e1.radius)) {
        // they are touching:
        // B3: Change direction while touching another Element
        e.angle += Math.PI * turn_rate;
        e1.angle += Math.PI * turn_rate;

        // B4: Move away from the overlapping Element
        e.x  +=  rx * avoid_rate;
        e.y  +=  ry * avoid_rate;
        e1.x += -rx * avoid_rate;
        e1.y += -ry * avoid_rate;

        // Set the value of the shortest possible line to black and the longest to white, with varying grays representing values in between.
        // longest possible is when they are just touching
        // so distance is the sum of each radius:
        let longest = e.radius + e1.radius;
        // get normalized distance,
        // result is between 0 and 1:
        let dn = distance / longest;
        // multiply by 255 for greyscale color:
        stroke(255 * dn);
        // Draw a line from the centers of Elements that are touching.
        line(e.x, e.y, e1.x, e1.y);
      }
    }

    // B2: Constrain to surface
    if (e.x < e.radius) {
      e.x = e.radius;
    } else if (e.x > width - e.radius) {
      e.x = width - e.radius;
    }
    if (e.y < e.radius) {
      e.y = e.radius;
    } else if (e.y > height - e.radius) {
      e.y = height - e.radius;
    }

    if (show_elements) {
      // draw element (for debugging):
      // ellipse arguments: position x,y and diameter
      stroke(128);
      ellipse(e.x, e.y, e.radius * 2);
      // also draw a line from element center
      // to element edge
      // in the element's direction:
      line(e.x, e.y, e.x + dx * e.radius, e.y + dy * e.radius);
    }
  }
}
```
</div>
	<div class="header">
		
		<h1>IAMD6013</h1>
		<h3>Special Focus <br/>Research and Innovation: <br/>
		<i>Artificial Nature </i></h3>	
		<h4>Winter 2021 </h4>	
		<a href="https://canvascloud.ocadu.ca/courses/948">Canvas</a><br/>
		<!--<a href="https://docs.google.com/spreadsheets/d/1UJS1sles269MEr1BGnkPuw7oxuuLUQ75ZF2_cj_XQq8/edit?usp=sharing">Studio visit (make-up)</a><br/><br/>
		<a href="https://docs.google.com/spreadsheets/d/19nq-ARKp5-dR1TJKXsAxsQ4I--vA4q6BQRt_Hb_S0iI/edit?usp=sharing">Attendance</a><br/>--><br/>
		<h3>Tutorial</h3>
	    <a href="https://channel9.msdn.com/Series/UnityCreativeCoding">Creative Codeing with Unity</a><br/>
		<h3>Schedule</h3>
<a href="index.html">Outline</a><br/>
				<a href="week01.html">1. Introduction</a><br/>
				<a href="week02.html">2. Endless Forms Most Beautiful I</a><br/>
				<a href="week03.html">3. Endless Forms Most Beautiful II</a><br/>
				<a href="week04.html">4. Endless Forms Most Beautiful III</a><br/>
				<a href="week05.html">5. Endless Forms Most Beautiful IV</a><br/>
				<a href=".html">6: A-Life Art</a><br/>
				<a href=".html">7: CAS & Art</a><br/>
				<a href=".html">8: Artificial Nature</a><br/>
				<a href=".html">9: Artificial Nature Supplement</a><br/>
				<a >10: Studio Practice</a><br/>
<a >11: Studio Practice</a><br/>
				<a href="week12.html">12: Final Exhibition</a><br/><br/>
				
	</div>
	<div class="section">
		<script type="text/javascript">
		//var converter = new Markdown.Converter();
		var converter = new Showdown.converter();
		document.write(converter.makeHtml($('#sourcetext').text()));
		</script>
	</div>
	
	<div class="footer">Haru (Hyunkyung) Ji, 2021</div>
	
</div>
</body>
</html>